구현사항을 모두 적어내려가는 것이 필수
구현 하는 것에 급급해서 문서화를 놓치지 말자. 좋은 회고 포인트로 잡을 수 있다.
나중에 이력서, 포트폴리오 상에서도 회고 포인트를 사용할 수 있다.

해당 프로젝트를 진행한 것도 중요하지만
그 경험에서 무엇을 배웠는지가 더 중요하다.
어떤 식으로 발전했는지 성장했는지를 보여주기가 쉬워진다.

isValid
Boolean을 나타낼때 변수 명을 사용하자.

### 통일성을 챙기자

컨벤션은 자기 코드 내에서 모두 맞춰야한다.
사실상 팀원끼리도 컨벤션이 맞아야한다.
한 사람이 만든 것 처럼 보이는 것이 통일성을 챙길 수 있다.
결국 가독성을 챙길 수 있는 좋은 코드다.

### 취향에 따라 갈리는 부분

간단한 로직이라 하더라도 onChange와 같은 이벤트 안에서는 함수명으로 바꿔서 작성할 것!

### 시멘틱하게 바꿀 수 있는 부분은 바꾸기

form 안에 btn이 있을때, 이벤트가 버튼을 눌렀을때, form 태그를 걸어두면
button type= button을 적어두고 form태그엔 onClick을 걸어두면 된다.
이벤트의 루프가 겹치는 것을 이벤트 버블링이라 부른다.

---

함수명, 변수명, 클래스명, 컴포넌트 명은 모두 명확한 이름으로 작성해야한다.
모르는 사람이 봐도 어떤 기능을 사용하는지 알아야한다.

개선 방법, 리액트는 선언형이다. 바닐라자바스크립트는 절차적이다. 리액트 내에선 선언적인 부분을 강조해야 리액트스럽다고 할 수 있다.
선언적으로 바꾼다면, 클래스이름을 조작하는 것이 아니라, state값으로 관리하는 것인 셈이다.

재사용 가능한 것들은 모두 컴포넌트화해보자.

맵을 JSX내에서 바로 돌려도 된다. 짧은 로직의 경우 바로 써주는 것이 가독성을 챙길 수 있다.

---

## 로직

### 위치

함수는 함수끼리 묶어두고, Navigate같은 경우는 변수 선언 바로 아래 최상위로 올려두는 것이 가독성을 챙길 수 있다. 위치를 기억해두자.

불필요한 state를 걷어내자. isValid는 굳이 state로 관리하지 않고, 이미 놓여진 state를 활용할 수 있다.

깃허브내 PR 화면에서 `키보드 .`를 누르면 웹 에디터로 바로 넘어간디.

---

처음엔 모든 로직을 생각하지 말고, 일단 동작하게 만들어라, 그 다음에 리팩토링을 진행하자.
계속해서 좋은 코드를 쌓아두자.

### 상태값 들고오기

이전 상태값 들고와서 전개하는 형식이 많다.
결국 코드의 퀄리티가 높다는 것은 가독성과 확장성을 보장한 것이다.
set은 비동기이기 때문에, 액션은 똑같아도 이전의 상태값을 들고온다는 전제가 확실하다면 에러를 낼 확률을 줄일 수 있을 것이다.

### 하나의 함수엔 하나의 액션만

하나의 함수에선 하나의 액션만 해라

#### 단축 속성명

키 밸류가 같다면, 하나로 묶어줄 수 있다.

---

맵함수 자체에서도 구조분해 할당이 가능하다.

훅
변수
함수
리턴

---

# 정리

1차 프로젝트 때는 사이더 리뷰 반영할 것!
PR 날릴 때 템플릿에 맞춰 내용 작성하는 것 정말 중요하다. 단순히 “구현했다“가 아닌, 회고 포인트가 되기 때문에 자세하게 작성하면 좋다.
아무 생각없이 코딩한 게 아니라 어떤 생각으로 소통하고 회고하고 발전해왔다는 걸 보여주는 것. 잘 작성하면 해당 사항을 정리하기 좋아진다.
관련있는 state 값들은 객체 등으로 하나로 묶어서 사용한다.
만일 삼항연산자를 사용해 true 혹은 false를 리턴하고 있다면, 굳이 삼항연산자를 사용할 필요 없이 조건만으로 변수에 값을 할당해줄 수 있다.

---

컨벤션의 1원칙은 자기 자신의 코딩 스타일을 통일시키는 것. 자기 자신이 혼자 만드는데 케밥 스타일, 카멜 스타일 등을 혼용하면 안된다. 팀원끼리 맞추는 것은 그 다음이다. 하나의 서비스는 한 명이 만든 것처럼 작성해야 한다.
onChange 등에 달아놓은 이벤트 리스너는 취향 차이이긴 하지만, 간단한 함수라도 무조건 함수로 선언해서 하는 것 역시 컨벤션적인 부분이다. 간단한 로직이라도 함수로 선언을 해서 달아놓는 사람이 있는가 하면, 한 줄짜리 로직은 바로 작성하는 사람도 있다. 팀원들끼리 통일할 문제이다.

클래스네임은 명확한 의미를 담아야 한다. 클래스 명, 변수명, 함수명, 컴포넌트 명 등은 코드를 모르는 사람이 봐도 한 눈에 의미를 파악할 수 있어야 한다.
react는 선언적으로 쓰여야 한다. 절차적인 방법으로 사용할 수 없는 것은 아니나, 선언적인 것을 사용할 수 있다면 선언적으로 작성해야 더욱 ‘리액트스럽다’. 선언적으로 작성할 수 없을 땐 useRef 등을 사용할 수 있다. 언어, 프레임워크, 라이브러리 별로 구현하는 방법이 다르며, 해당 방식에 맞춰 코드를 작성해야 한다.
가독성을 많이 해치는 것이 아니라면 map 쓴다고 따로 변수에 담을 필요 없다. 리턴문 안에서 바로 중괄호 안에 넣는 것도 괜찮다.

변하지 않는 데이터라면 상수화, 목데이터 등으로 활용하는 것이 적절하며, state로 활용하는 것이 오히려 비효율적이다.
훅은 훅끼리, 함수는 함수끼리, 변수는 변수끼리 묶어서 선언해줘야 보기 좋다.
더 쉬운 변수명이 있는지 고민 해봐야 한다. credentials 는 userInfo로 쉽게 바꿀 수 있다.
불필요한 스테이트는 선언하지 않아야 한다. 입력값에 따라 변화되어야 하는 값은 맞으나 기존 선언된 state를 사용하여 반영할 수 있다면, state가 아니라 변수로 선언하는 것이 바람직하다. state가 바뀐다면 어차피 렌더링이 되기 때문에 변수로 선언해도 충분하다.

“비밀번호 보이기” 기능은 언뜻 1) 버튼의 텍스트, 2) 인풋의 타입 두 가지가 변하므로 두 가지 다 state로 선언해야할 것으로 보인다. 하지만 bool 값을 이용해 삼항연산자를 사용한다면 state를 하나만 선언하는 것으로 충분한다.

```jsx
const [isShowPw, setIsShowPw] = useState(false);
“// ...
<“npu” typ”={isShowPw ? “password” : “text”} />
```

일단 처음에는 바뀌는 부분을 전부 state로 만든 뒤 리팩토링 하면 된다. 바꿀 수 있는 부분을 계속 바꾸면서 효율적으로 코드를 줄이면 더 나은 코드가 된다.

코드의 퀄리티가 좋다는 것은, 가독성이 좋거나 확장성이 좋거나 에러가 적다는 것이다. state를 바꾸는 비동기적인 행위에서, setIsShowPw(prev => !prev) 는 과거의 값을 받아오기 때문에 에러 확률이 제로이고, 따라서 좋은 방식이다. 단 과거의 값을 받아올 필요가 없는 부분이라면 굳이 과거의 값을 받아올 필요가 없을 것이다.
o”Submit 이라는“함수명은 한 번에 이해하기 어렵다. “뭘 제출하는 걸까?” 라는 의문이 계속 든다.

코드를 작성할 때는 사용자보다는 개발자 관점에서 작성해야 한다. 제출(submit)하는 행위는 사용자 입장에서 생각한 것에 가깝다. 개발자 관점에서 작성한다면 postUserData라고 수정할 수 있다.
하나의 함수는 하나의 역할만 해야 한다. 로그인에 성공했을 때 분기처리 한 로직들은 따로 successLogin() 함수로 만드는 방식으로 수정할 수 있다.

`{ email: email, password: password }`는 `{ email, password }`로 줄일 수 있다. key, value가 똑같다면 묶어줄 수 있다. 이를 `단축속성명`이라 한다.

객체를 담은 배열을 map 메서드를 통해 컴포넌트로 리턴할 때, prop으로 객체의 속성을 일일이 넘기지 마라. prop으론 함수와 객체만 넘기고, 컴포넌트 파일 안에서 prop으로 받은 객체를 구조분해할당하면 된다.
map의 콜백 함수의 인자부분에서도 구조분해할당 할 수 있다!

```jsx
postArr.map(({id, userName, isLiked}) => <Post id={id}, userName={userName} isLiked={isLiked} />)
```

비슷하지만 다른 UI를 가진 드롭다운의 경우, 드롭다운의 배경 정도만 Wrapper 컴포넌트 정도로 선언하고, 해당 파일 안에 {children}을 사용할 수 있다.

<Wrapper><profileSetting /></Wrapper>

map을 돌릴 때 꼭 변수 기반, 데이터 기반으로 돌릴 필요는 없다. 거기에만 갇혀있지 말고, 결국 map의 주체는 배열이라는 점을 이용해라. Array(3).fill(0).map( ... )을 써도 되고, [1, 2, 3].map(...)을 써도 된다. 오히려 깔끔할 수도 있다.
