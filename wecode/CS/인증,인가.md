## 인증은 왜 필요한가?

> 개발자 입장에서 웹, 앱 서비스를 바라볼때 사용자를 식별하기 위해,
> 사용자가 어떤 행동을 했는지 추적하기 위해서다

인증에 필요한 것

- ID, Email, Password
- 가장 중요한 것은 Password

비밀번호는 어떻게 관리해야하는가?

- 데이터베이스 저장시 개인 정보를 해싱하여 복원할 수 없게한다.
  ![](https://velog.velcdn.com/images/willy4202/post/e05609f9-dc96-4e8b-b4de-dd7cda553768/image.png)
  원본값을 유추할 수 없을 정도다.

HTTPS를 활용해 개인 정보를 주고받을 때 암호화를 적용한다.
![](https://velog.velcdn.com/images/willy4202/post/d42873e6-6d18-47e4-b5fe-3703a14360c0/image.png)

실제 프로덕션 환경이라면 HTTPS를 적용해야하고

### SSL

- 통신을 주고받는 과정에서 보안 레이어를 한겹 더 둘러싸는 기술이다.
- 데이터가 탈취당하더라도 암호화되어 있기 때문에 볼 수 없다.

## 암호화?

#### 단방향 해쉬

- 복원이 불가능하다. 원본값을 유추할 수 없다.
- 그러나 같은 값을 넣으면 매번 같은 값으로 해시된다는 것을 알 수 있다.

![](https://velog.velcdn.com/images/willy4202/post/882222bc-e95d-4e33-bda2-7824de4677a4/image.png)

결과적으로 모든 경우의 값을 테이블로 만들어 파는 곳도 있다. 이를 '레인보우 테이블'이라고 부른다.
해시값을 유추할 수 있으니, 암호화가 뚫릴수도 있다.

이 같은 허점을 보완하고자 `salting`, `key stretching`이라는 기술이 나타났다.
비밀번호와 임의로 생성한 문자열을 합쳐서 해시값을 저장하는 방법이다.

#### Salting, KeyStretching

- 단순 해쉬값은 해킹에 취약하기 때문에 솔팅이 나타났다.
  ![](https://velog.velcdn.com/images/willy4202/post/8cea326b-cc78-471d-a774-4863405e4db9/image.png)

-입력한 비밀번호와 임의로 생성한 문자열을 합쳐서 해싱을 거치고, 값을 저장하는 방법이다.

---

## bcrypt

솔팅과 키 스트레칭을 구현해주는 대표적인 라이브러리

- 비크립트는 앞서 말한 개념들을 쉽게 적용해준다.
- hash결과값에 salt값과 hash값 및 반복횟수를 같이 보관하기 때문에, 비밀번호 해싱을 적용하는데 있어 DB 설계에 복잡하게 할 필요가 없다.
- 번거로운 과정을 생략하고, 해당 라이브러리를 활용해 개발에만 집중하기 위함

![](https://velog.velcdn.com/images/willy4202/post/59208129-d214-494b-99ce-df6ef09e0ea8/image.png)

---

# 인가는 무엇인가?

### Authorization

- 해당 유저가 request에 해당하는 권한이 있는지 확인하는 절차
- Http의 특징은 무엇인가?

  - request/response
  - stateless한 성질

stateless 하다면 요청할때마다 로그인해야하는 번거로움이 있을 것이다.
서비스를 사용하는 입장에서도 경험이 좋지 못하다.
이를 해결하기 위해서 인가를 해줘야한다.

---

서버는 사용자가 로그인했을 경우 어떻게 알 수 있을까?

- headers에 메타데이터를 보내서 확인한다
- 이 정보를 Json Web Token, `JWT`라고 한다.

![](https://velog.velcdn.com/images/willy4202/post/d2449de4-f914-4d7f-8335-56204f15aeee/image.png)

로그인 성공시 토큰을 보내고 해당 토큰을 활용해서 stateless한 성질을 해결할 수 있다.
모든 api를 호출할 때마다, 토큰을 이용해서 인증 과정을 넘길 수 있다.

### JSON WEB TOKEN

#### HEADER

토큰에는 해시 알고리즘 정보가 들어간다.

- 헤더의 내용은 BASE64 방식으로 `인코딩`해서 JWT의 가장 첫부분에 기록된다.
  ![](https://velog.velcdn.com/images/willy4202/post/557567be-81d7-4606-a22d-2d98a0e9b99d/image.png)

이 과정에서 개인정보를 기입해선 안된다. 인코딩은 형태 변환이기 때문이다. 암호화가 아니다.

#### PAYLOAD

만료 시간을 나타내는 exp와 같이 미리 정의된 집합인 registered claim
개인 정보를 넣어선 안되지만, 개인을 식별할 수 있는 정보는 넣어도 된다.
로그인 성공시 데이터베이스에서 유저 아이디와 관련된 pk를 달아준다.

일종의 놀이공원 자유이용권에 이름을 박아주는 것과 비슷한 맥락이다
`1년간 개인 자유이용권`인 셈이다

헤더와 내용은 어디까지나 인코딩이기 때문에
비밀번호와 같은 민감한 데이터는 저장해두지 않는다는 것을 기억해두자.

#### signature

해당 토큰이 서버에서 발급한 토큰이 맞는 것인지에 대한 검증과정이다.

- JWT가 원본 그대로라는 것을 확인할때 사용한다.
- 시그니쳐는 BASE64URL로 인코드된 header, payload 그리고 JWT secret을 헤더에 지정된 암호 알고리즘으로 암호화해서 전송한다. (복호화 가능)
- 프론트엔드가 JWT를 백엔드 API로 전송하면, 서보에서 전송받은 JWT의 서명 부분을 복호화하여 서버에서 생성한 JWT가 맞는지 확인한다.
- 마치 계약서의 위변조를 막기 위해 서로 사인하는 것과 같다.

![](https://velog.velcdn.com/images/willy4202/post/4a2346c7-4142-4d8f-8f52-788e9ac0c749/image.png)

암호화가 아닌 인코딩된 정보가 첫 파트에 저장되고, 내용에는 DB의 유저 PK값과 유효기간을 담아 넘겨준다.
마지막엔 암호화를 적용하는데, 시크릿키와 해싱을 적용해서 토큰을 구성한다.

---

앞서 말한 인증 과정은 bcrypt를 사용한다.
어떠한 이유로 해당 라이브러리를 사용했는지, 말할 수 있어야한다.

매번 로그인해야하는 http stateless라는 특성을 인가를 통해 상쇄할 수 있다.
기본에 충실하고 더 나은 방향을 찾는 것이 좋기에,
JWT을 활용해서 인가를 구현해보자.
